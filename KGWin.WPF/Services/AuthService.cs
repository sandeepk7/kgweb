using Esri.ArcGISRuntime.Portal;
using Esri.ArcGISRuntime;
using Esri.ArcGISRuntime.Security;
using KGWin.WPF.Interfaces;
using Microsoft.Extensions.Configuration;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Navigation;
using System.Windows.Threading;

namespace KGWin.WPF.Services
{
    public class AuthService : IAuthService
    {
        private readonly IConfiguration _configuration;
        readonly ILicenseService _licenseService;

        private bool _isLoginInProgress;
        private bool _isUserAuthenticated;
        public bool IsUserAuthenticated
        {
            get => _isUserAuthenticated;           
            private set => _isUserAuthenticated = value;
        }

        public string? AuthenticatedUserName { get; private set; }

        public AuthService(IConfiguration configuration, ILicenseService licenseService)
        {
            _configuration = configuration;
            _licenseService = licenseService;
        }

        public async Task LoginAsync()
        {
            _isLoginInProgress = true;
            string loginUrl = _configuration["ArcGISLogin:ArcGISUrl"]!;
            SetChallengeHandler(_configuration);

            try
            {
                var requestInfo = new CredentialRequestInfo
                {
                    ServiceUri = new Uri(loginUrl),
                    AuthenticationType = AuthenticationType.Token
                };

                var credential = await AuthenticationManager.Current.GetCredentialAsync(requestInfo, false);

                if (credential != null)
                {
                    AuthenticatedUserName = await _licenseService.SaveLicense();
                    IsUserAuthenticated = true;

                    MessageBox.Show("Authenticated Successfull");
                    _isLoginInProgress = false;
                    return;
                }
            }
            catch (Exception ex)
            {
                _isLoginInProgress = false;
                MessageBox.Show($"Login failed: {ex.Message}", "Authentication Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }

            IsUserAuthenticated = false;
            _isLoginInProgress = false;
        }

        public async Task<bool> CheckUserAuthenticated()
        {
            if (IsUserAuthenticated) return true;

            if (!_isLoginInProgress)
            {
                await LoginAsync();
            }

            while (_isLoginInProgress)
            {
                await Task.Delay(100);
            }
            return IsUserAuthenticated;
        }

        public static void SetChallengeHandler(IConfiguration configuration)
        {
            string LoginUrl = configuration["ArcGISLogin:ArcGISUrl"]!;
            string ClientId = configuration["ArcGISLogin:ArcGISClientId"]!;
            string RedirectUrl = configuration["ArcGISLogin:ArcGISOAuthRedirectUrl"]!;

            var userConfig = new OAuthUserConfiguration(new Uri(LoginUrl), ClientId, new Uri(RedirectUrl));
            AuthenticationManager.Current.OAuthUserConfigurations.Add(userConfig);
            AuthenticationManager.Current.OAuthAuthorizeHandler = new OAuthAuthorize();
        }

        #region OAuth handler

        // In a desktop (WPF) app, an IOAuthAuthorizeHandler component is used to handle some of the OAuth details. Specifically, it
        //     implements AuthorizeAsync to show the login UI (generated by the server that hosts secure content) in a web control.
        //     When the user logs in successfully, cancels the login, or closes the window without continuing, the IOAuthAuthorizeHandler
        //     is responsible for obtaining the authorization from the server or raising an OperationCanceledException.
        public class OAuthAuthorize : IOAuthAuthorizeHandler
        {
            // Window to contain the OAuth UI.
            private Window _authWindow;

            // Use a TaskCompletionSource to track the completion of the authorization.
            private TaskCompletionSource<IDictionary<string, string>> _tcs;

            // URL for the authorization callback result (the redirect URI configured for your application).
            private string _callbackUrl;

            // URL that handles the OAuth request.
            private string _authorizeUrl;

            // Function to handle authorization requests, takes the URIs for the secured service, the authorization endpoint, and the redirect URI.
            public Task<IDictionary<string, string>> AuthorizeAsync(Uri serviceUri, Uri authorizeUri, Uri callbackUri)
            {
                if (_tcs != null && !_tcs.Task.IsCompleted)
                    throw new Exception("Task in progress");

                _tcs = new TaskCompletionSource<IDictionary<string, string>>();

                // Store the authorization and redirect URLs.
                _authorizeUrl = authorizeUri.AbsoluteUri;
                _callbackUrl = callbackUri.AbsoluteUri;

                // Call a function to show the login controls, make sure it runs on the UI thread for this app.
                Dispatcher dispatcher = Application.Current.Dispatcher;
                if (dispatcher == null || dispatcher.CheckAccess())
                {
                    AuthorizeOnUIThread(_authorizeUrl);
                }
                else
                {
                    Action authorizeOnUIAction = () => AuthorizeOnUIThread(_authorizeUrl);
                    dispatcher.BeginInvoke(authorizeOnUIAction);
                }

                // Return the task associated with the TaskCompletionSource.
                return _tcs.Task;
            }

            // Challenge for OAuth credentials on the UI thread.
            private void AuthorizeOnUIThread(string authorizeUri)
            {
                // Create a WebBrowser control to display the authorize page.
                WebBrowser webBrowser = new WebBrowser();

                // Handle the navigation event for the browser to check for a response to the redirect URL.
                webBrowser.Navigating += WebBrowserOnNavigating;

                // Display the web browser in a new window.
                _authWindow = new Window
                {
                    Content = webBrowser,
                    Width = 450,
                    Height = 450,
                    WindowStartupLocation = WindowStartupLocation.CenterOwner
                };

                // Set the app's window as the owner of the browser window (if main window closes, so will the browser).
                if (Application.Current != null && Application.Current.MainWindow != null)
                {
                    _authWindow.Owner = Application.Current.MainWindow;
                }

                // Handle the window closed event then navigate to the authorize url.
                _authWindow.Closed += OnWindowClosed;
                webBrowser.Navigate(authorizeUri);

                // Display the window.
                _authWindow.ShowDialog();
            }

            // Handle the browser window closing.
            private void OnWindowClosed(object sender, EventArgs e)
            {
                // If the browser window closes, return the focus to the main window.
                if (_authWindow != null && _authWindow.Owner != null)
                {
                    _authWindow.Owner.Focus();
                }

                // If the task wasn't completed, the user must have closed the window without logging in.
                if (!_tcs.Task.IsCompleted)
                {
                    // Set the task completion source exception to indicate a canceled operation.
                    _tcs.SetCanceled();
                }

                _authWindow = null;
            }

            // Handle browser navigation (content changing).
            private void WebBrowserOnNavigating(object sender, NavigatingCancelEventArgs e)
            {
                // Check for a response to the callback url.
                const string portalApprovalMarker = "/oauth2/approval";
                WebBrowser webBrowser = sender as WebBrowser;

                Uri uri = e.Uri;

                // If no browser, uri, or an empty url, return.
                if (webBrowser == null || uri == null || string.IsNullOrEmpty(uri.AbsoluteUri))
                    return;

                // Check for redirect.
                bool isRedirected = uri.AbsoluteUri.StartsWith(_callbackUrl) ||
                    _callbackUrl.Contains(portalApprovalMarker) && uri.AbsoluteUri.Contains(portalApprovalMarker);

                // Check if browser was redirected to the callback URL. (This indicates succesful authentication.)
                if (isRedirected)
                {
                    e.Cancel = true;

                    // Call a helper function to decode the response parameters.
                    IDictionary<string, string> authResponse = DecodeParameters(uri);

                    // Set the result for the task completion source.
                    _tcs.SetResult(authResponse);

                    // Close the window.
                    if (_authWindow != null)
                    {
                        _authWindow.Close();
                    }
                }
            }

            private static IDictionary<string, string> DecodeParameters(Uri uri)
            {
                // Create a dictionary of key value pairs returned in an OAuth authorization response URI query string.
                string answer = "";

                // Get the values from the URI fragment or query string.
                if (!string.IsNullOrEmpty(uri.Fragment))
                {
                    answer = uri.Fragment.Substring(1);
                }
                else
                {
                    if (!string.IsNullOrEmpty(uri.Query))
                    {
                        answer = uri.Query.Substring(1);
                    }
                }

                // Parse parameters into key / value pairs.
                Dictionary<string, string> keyValueDictionary = new Dictionary<string, string>();
                string[] keysAndValues = answer.Split(new[] { '&' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (string kvString in keysAndValues)
                {
                    string[] pair = kvString.Split('=');
                    string key = pair[0];
                    string value = string.Empty;
                    if (key.Length > 1)
                    {
                        value = Uri.UnescapeDataString(pair[1]);
                    }

                    keyValueDictionary.Add(key, value);
                }

                // Return the dictionary of string keys/values.
                return keyValueDictionary;
            }
        }

        #endregion OAuth handler
    }
}